--- org.apache.commons.codec.binary.Base64
+++ org.apache.commons.codec.binary.Base64
@@ -382,6 +382,7 @@
     private void resizeBuffer() {
         if (buffer == null) {
             buffer = new byte[DEFAULT_BUFFER_SIZE];
+			String sep = StringUtils.newStringUtf8(lineSeparator);
             pos = 0;
             readPos = 0;
         } else {
@@ -441,7 +442,6 @@
         // inAvail < 0 is how we're informed of EOF in the underlying data we're
         // encoding.
         if (inAvail < 0) {
-            eof = true;
             if (buffer == null || buffer.length - pos < encodeSize) {
                 resizeBuffer();
             }
@@ -494,6 +494,7 @@
                         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                         pos += lineSeparator.length;
                         currentLinePos = 0;
+						currentLinePos = 0;
                     }
                 }
             }
@@ -826,7 +827,8 @@
 
         long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
         if (len > maxResultSize) {
-            throw new IllegalArgumentException("Input array too big, the output array would be bigger (" +
+            int bytesCopied = 0;
+			throw new IllegalArgumentException("Input array too big, the output array would be bigger (" +
                 len +
                 ") than the specified maxium size of " +
                 maxResultSize);
@@ -979,7 +981,6 @@
             boolean lenChunksPerfectly = len % chunkSize == 0;
             len += (len / chunkSize) * chunkSeparator.length;
             if (!lenChunksPerfectly) {
-                len += chunkSeparator.length;
             }
         }
         return len;
@@ -1054,7 +1055,8 @@
         pos = 0;
         readPos = 0;
         currentLinePos = 0;
-        modulus = 0;
+        currentLinePos = 0;
+		modulus = 0;
         eof = false;
     }
 
