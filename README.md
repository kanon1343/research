# 修正後のプログラムの分析

seedがあるため分けている  
## analyze_code()で分析を行う  
- lizardを使用して分析  
公式のgitURL(https://github.com/terryyin/lizard)
    - nloc : メソッドやファイルのコード行数（コメントを除く）
    - ccn : 循環的複雑度。if文、for文、switch-case文が増えると数値が上がります。0〜10は最良、11〜20はやや複雑、21〜40はテストしづらい、50以上は危険。
    - token : コンパイラが字句解析／構文解析する際の最小単位（要素）であり、ここでは関数中のトークン数
    - param : メソッドのパラメータ数
    - length : メソッドやファイルのコード行数（コメントを含む)  
- analyze.csvとして出力

## analyze_element()で分析結果を整形
- lizardはメソッド単位での出力されるので、ファイル単位に整形
- 名前をkGenProgの出力形式に整形(org.apache.~~.java)
- 修正行数はget_repair_lines()から取ってくる
    - .diffファイル内の"+"、"-"の数を計算
    - 空白を消しているだけのは無視
    - 出力数分を辞書型で返す
- metrics.csvとして出力(修正行数の出力はこの段階ではいらないかも)

## get_point()で出力ファイルあたりのポイントを計算し、グラフ化とポイントを出力
- 修正前と修正後の同じファイルを１つのファイルにする→diff.csvを出力
- diff.csvを利用してポイント化
    - nloc、token、修正行数は差分を計算
    - ccnは修正後から修正前を引いた(改善されるのはいいことだから、マイナスもあり得る)
    - tokenは大きくなってしまうのでとりあえず10で割っている
- ポイントを出力してグラフ化(ポイントはwordにメモ)
- draw_graphを使用してグラフを書く


# defects4jの元ファイルの分析
- 基本的にやっていることは修正後のプログラム分析と同じ
- seedがないため便宜上分けている
- 語尾にdefects4jがつく関数が該当する
